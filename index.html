<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Поле Чудес</title>
  <script src="./react.development.js"></script>
  <script src="./react-dom.development.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/@babel/standalone@7.27.2/babel.min.js"></script>
  <style>
    .letter-box {
      width: 50px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: #2d3748;
      border: 2px solid #4a5568;
      font-size: 24px;
      font-weight: bold;
      margin: 5px;
      transition: transform 0.5s ease, background-color 0.3s;
      position: relative;
      overflow: visible;
    }
    .letter-box.revealed {
      background-color: #f6ad55;
      color: #1a202c;
    }
    .letter-box.shake {
      animation: shakeLetter 3.5s ease-out;
    }
    @keyframes shakeLetter {
      0% { transform: translateX(0); }
      10% { transform: translateX(-10px); }
      20% { transform: translateX(10px); }
      30% { transform: translateX(-10px); }
      40% { transform: translateX(10px); }
      50% { transform: translateX(-8px); }
      60% { transform: translateX(8px); }
      70% { transform: translateX(-6px); }
      80% { transform: translateX(6px); }
      90% { transform: translateX(-4px); }
      100% { transform: translateX(0); }
    }
    .letter-box.wrong-word-shake {
      animation: wrongWordShake 3.5s ease-out;
    }
    @keyframes wrongWordShake {
      0% { transform: translateX(0); }
      10% { transform: translateX(calc(var(--index) * -5px)); }
      20% { transform: translateX(calc(var(--index) * 5px)); }
      30% { transform: translateX(calc(var(--index) * -5px)); }
      40% { transform: translateX(calc(var(--index) * 5px)); }
      50% { transform: translateX(calc(var(--index) * -3px)); }
      60% { transform: translateX(calc(var(--index) * 3px)); }
      70% { transform: translateX(calc(var(--index) * -2px)); }
      80% { transform: translateX(calc(var(--index) * 2px)); }
      90% { transform: translateX(calc(var(--index) * -1px)); }
      100% { transform: translateX(0); }
    }
    .wheel-pointer {
      position: absolute;
      top: -20px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 15px solid transparent;
      border-right: 15px solid transparent;
      border-bottom: 30px solid red;
      z-index: 10;
    }
    .player-active {
      box-shadow: 0 0 0 3px #f6ad55;
    }
    .word-slider {
      position: fixed;
      bottom: -300px;
      left: 0;
      right: 0;
      background-color: #2d3748;
      padding: 20px;
      border-radius: 20px 20px 0 0;
      box-shadow: 0 -5px 15px rgba(0,0,0,0.3);
      transition: bottom 0.3s ease-out;
      z-index: 100;
    }
    .word-slider.open {
      bottom: 0;
    }
    .slide-up-button {
      animation: slideUp 0.5s ease-out forwards;
    }
    @keyframes slideUp {
      from { transform: translateY(100px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    .blitz-answer {
      width: 20px;
      height: 20px;
      display: inline-block;
      margin-left: 10px;
    }
    .blitz-correct {
      color: green;
    }
    .blitz-wrong {
      color: red;
    }
    .podium {
      display: flex;
      justify-content: center;
      align-items: flex-end;
      height: 400px;
      width: 100%;
      max-width: 600px;
      margin: 0 auto;
      opacity: 0;
      animation: podiumFadeIn 1s ease-out forwards;
      position: relative;
      overflow: visible;
    }
    @keyframes podiumFadeIn {
      from { opacity: 0; transform: scale(0.5); }
      to { opacity: 1; transform: scale(1); }
    }
    .podium-step {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      padding: 10px;
      opacity: 0;
      transition: opacity 0.5s ease-out;
    }
    .podium-step:nth-child(1) { height: 300px; background-color: #FFD700; } /* Золотой для 1-го места */
    .podium-step:nth-child(2) { height: 250px; background-color: #C0C0C0; } /* Серебряный для 2-го места */
    .podium-step:nth-child(3) { height: 200px; background-color: #CD7F32; } /* Бронзовый для 3-го места */
    .podium-step.visible {
      opacity: 1;
    }
    .podium-team {
      margin-top: 10px;
      font-size: 20px;
      font-weight: bold;
    }
    .volume-slider {
      width: 100px;
      margin: 10px auto;
    }
    .floating-circle {
      position: absolute;
      border-radius: 50%;
      opacity: 0.7;
    }
    @keyframes floatCircle {
      0% { transform: translate(0, 0); opacity: 0.7; }
      50% { opacity: 0.4; }
      100% { transform: translate(var(--move-x), var(--move-y)); opacity: 0; }
    }
  </style>
</head>
<body class="bg-gray-900 text-white">
  <div id="root"></div>
  <audio id="blitz-start-audio" src="блиц-вопрос начальное окошко.mp3"></audio>
  <audio id="correct-blitz-audio" src="Верный ответ в блиц-вопросе.mp3"></audio>
  <audio id="wheel-spin-audio" src="Кручение барабана.mp3"></audio>
  <audio id="wrong-word-audio" src="Названо неверное слово целиком.mp3"></audio>
  <audio id="wrong-blitz-audio" src="Неверный ответ в блиц-вопросе.mp3"></audio>
  <audio id="wrong-letter-audio" src="Неправильно отгадана буква в слове.mp3"></audio>
  <audio id="correct-letter-audio" src="Правильно отгадана буква в слове.mp3"></audio>
  <audio id="word-guess-audio" src="word-guess.mp3"></audio>
  <audio id="plus-sector-audio" src="сектор плюс.mp3"></audio>
  <audio id="blackbox-sector-audio" src="сектор чёрный ящик.mp3"></audio>
  <audio id="podium-fanfare-audio" src="Фанфары когда показываются 1,2,3 место и результаты игры.mp3"></audio>

  <script type="text/babel">
    // Данные игры
    const wordPool = [
      { word: "БУРАВКИН", question: "Фамилию какого белорусского поэта и общественного деятеля носит автор слов гимна Полоцкого государственного университета?" },
      { word: "ПАРАБОЛОИД", question: "Какая композиция, расположенная возле старого корпуса, отображает единение науки и современного искусства, став для нашего вуза своеобразным символом в год научных свершений и открытий?" },
      { word: "ПЕРЕКРЁСТОК", question: "Налево пойдёшь – перо найдёшь, направо пойдёшь – копейку найдёшь, прямо пойдёшь – знания получишь, назад пойдёшь – домой уйдёшь, о каком месте идёт речь?" },
      { word: "КОЛЛЕГИУМ", question: "Меня возвели для мудрости, но я не храм. Наполняли знаниями, но я не библиотека. Много раз ломали, но я не сломлен. Кто я?" },
      { word: "БАЛКОН", question: "Его топило, но он не тонул. На нём было много людей, но он не митинг и всегда находился выше земли." },
      { word: "СФИНКС", question: "Мифическое существо с телом льва и головой человека, охраняющее загадки." },
      { word: "ГЕРАКЛ", question: "Герой древнегреческих мифов, известный своими двенадцатью подвигами." },
      { word: "ПИРАМИДА", question: "Архитектурное сооружение, служившее гробницей фараонам в Древнем Египте." },
      { word: "ОЛИМП", question: "Гора, где, согласно мифам, обитали древнегреческие боги." },
      { word: "АФИНА", question: "Богиня мудрости и войны в древнегреческой мифологии." },
      { word: "ЭЙФЕЛЬ", question: "Фамилия архитектора, создавшего знаменитую башню в Париже." },
      { word: "КОЛИЗЕЙ", question: "Древнеримский амфитеатр, где проводились гладиаторские бои." },
      { word: "КРЕМЛЬ", question: "Историческая крепость в центре Москвы, символ России." },
      { word: "САХАРА", question: "Крупнейшая пустыня в мире, расположенная в Северной Африке." },
      { word: "АМАЗОНКА", question: "Самая длинная река в мире, протекающая через Южную Америку." }
    ];

    const gameData = {
      rounds: [],
      finalRound: { theme: "Кино", word: "ОСКАР", question: "Самая престижная кинопремия" },
      blitzQuestionsPool: [
        "Кол-во корпусов ПГУ? (5)", "В каком году было 11 факультетов в ПГУ? (2005)", "Кол-во ректоров за всю историю ПГУ? (около 15)",
        "В каком корпусе нет актового зала? (4-й корпус)", "Перевод фразы «DOCENDO DISCIMUS»? (Уча учим)", "Сколько лет студенческому центру? (около 20)",
        "На каком факультете располагаются 2 уникальные специальности в РБ? (Факультет компьютерных технологий)", "Спортивный снаряд для игры в хоккей? (Клюшка)",
        "Какой символ Полоцка, связанный с иезуитским наследием, украшает главный вход университета? (Крест иезуитов)",
        "Какое архитектурное сооружение рядом с ПГУ было построено в честь 300-летия Полоцкой епархии? (Софийский собор)",
        "Какой факультет ПГУ был основан последним в XXI веке? (Факультет экономики и права)", "В каком году ПГУ получил современное название? (1993)",
        "Эти люди основали альмаматр? (Иезуиты)", "Самый главный человек на факультете? (Декан)", "Фамилия ректора, пробывшего на посту 1 год? (Ковалёв)",
        "Сколько цветов на эмблеме ПГУ? (3)", "Какой предмет обязателен для всех студентов ПГУ? (Физическая культура)", "Как называется студенческая газета ПГУ? (Вестник ПГУ)",
        "Какое событие отмечается в ПГУ 1 сентября? (День знаний)", "Как называется научный журнал ПГУ? (Вестник Полоцкого государственного университета)",
        "Как называется Wi-Fi сеть, доступная студентам в новом корпусе? (PSU_Student)", "Как называется объединение ПГУ для поддержки талантливой молодёжи? (Совет молодых учёных)",
        "Как называется ежегодный конкурс научных работ среди студентов ПГУ? (Научная весна)", "Как называется программа обмена студентами ПГУ с зарубежными вузами? (Erasmus+)",
        "В каком году ПГУ начал реализацию программы двойных дипломов? (2016)"
      ]
    };

    function generateRounds() {
      const selectedWords = wordPool.slice(0, 5);
      const rounds = selectedWords.map(item => ({ word: item.word, question: item.question }));
      gameData.rounds = rounds;
    }

    const wheelSectors = [
      { type: "points", value: 350 }, { type: "points", value: 400 }, { type: "points", value: 450 },
      { type: "points", value: 500 }, { type: "points", value: 600 }, { type: "points", value: 650 },
      { type: "points", value: 700 }, { type: "points", value: 750 }, { type: "points", value: 800 },
      { type: "points", value: 850 }, { type: "points", value: 950 }, { type: "points", value: 1000 },
      { type: "blackbox", value: 0 }, { type: "blitz", value: 0 }, { type: "plus", value: 0 }, { type: "plus", value: 0 }
    ];

    function App() {
      const [gameState, setGameState] = React.useState("teamInput");
      const [teams, setTeams] = React.useState([]);
      const [currentRound, setCurrentRound] = React.useState(0);
      const [revealedLetters, setRevealedLetters] = React.useState([]);
      const [usedLetters, setUsedLetters] = React.useState([]);
      const [wheelSpinning, setWheelSpinning] = React.useState(false);
      const [currentSector, setCurrentSector] = React.useState(null);
      const [currentPlayerIndex, setCurrentPlayerIndex] = React.useState(0);
      const [scores, setScores] = React.useState({});
      const [winners, setWinners] = React.useState([]);
      const [blackBoxVisible, setBlackBoxVisible] = React.useState(false);
      const [hasBlackBoxTriggered, setHasBlackBoxTriggered] = React.useState(false);
      const [showBlackBoxChoice, setShowBlackBoxChoice] = React.useState(false);
      const [showWordSlider, setShowWordSlider] = React.useState(false);
      const [wordGuess, setWordGuess] = React.useState("");
      const [showBlitz, setShowBlitz] = React.useState(false);
      const [blitzStarted, setBlitzStarted] = React.useState(false);
      const [blitzAnswers, setBlitzAnswers] = React.useState([]);
      const [blitzTimer, setBlitzTimer] = React.useState(null);
      const [timeLeft, setTimeLeft] = React.useState(10);
      const [finalAngle, setFinalAngle] = React.useState(0);
      const [spinsInCurrentRound, setSpinsInCurrentRound] = React.useState(0);
      const [totalSpins, setTotalSpins] = React.useState(0);
      const [podiumTeams, setPodiumTeams] = React.useState([]);
      const [podiumVisible, setPodiumVisible] = React.useState({ 1: false, 2: false, 3: false });
      const [showPlusChoice, setShowPlusChoice] = React.useState(false);
      const [animationIndex, setAnimationIndex] = React.useState(null);
      const [usedBlitzQuestions, setUsedBlitzQuestions] = React.useState([]);
      const [currentBlitzQuestions, setCurrentBlitzQuestions] = React.useState([]);
      const [volume, setVolume] = React.useState(0.5);
      const [letterShakeTimeout, setLetterShakeTimeout] = React.useState(null);
      const [wordShakeTimeout, setWordShakeTimeout] = React.useState(null);
      const [activeAudios, setActiveAudios] = React.useState([]);
      const [hasBlitzTriggeredInCurrentRound, setHasBlitzTriggeredInCurrentRound] = React.useState(false);
      const [blitzSpinIndex, setBlitzSpinIndex] = React.useState(null);

      React.useEffect(() => {
        if (currentRound >= 0 && !hasBlitzTriggeredInCurrentRound) {
          setBlitzSpinIndex(Math.floor(Math.random() * (9 - 4 + 1)) + 4);
        }
      }, [currentRound, hasBlitzTriggeredInCurrentRound]);

      const startGame = (teamNames) => {
        generateRounds();
        const initialTeams = teamNames.filter(name => name.trim() !== "");
        const initialScores = {};
        initialTeams.forEach(team => { initialScores[team] = 0; });
        setTeams(initialTeams);
        setScores(initialScores);
        setCurrentRound(0);
        setRevealedLetters([]);
        setUsedLetters([]);
        setCurrentPlayerIndex(0);
        setWinners([]);
        setHasBlackBoxTriggered(false);
        setSpinsInCurrentRound(0);
        setTotalSpins(0);
        setPodiumTeams([]);
        setPodiumVisible({ 1: false, 2: false, 3: false });
        setShowPlusChoice(false);
        setAnimationIndex(null);
        setUsedBlitzQuestions([]);
        setCurrentBlitzQuestions([]);
        setHasBlitzTriggeredInCurrentRound(false);
        setBlitzSpinIndex(Math.floor(Math.random() * (9 - 4 + 1)) + 4);
        setGameState("roundIntro");
      };

      const startRound = () => {
        setRevealedLetters([]);
        setUsedLetters([]);
        setCurrentPlayerIndex(Math.floor(Math.random() * teams.length));
        setSpinsInCurrentRound(0);
        setHasBlitzTriggeredInCurrentRound(false);
        setBlitzSpinIndex(Math.floor(Math.random() * (9 - 4 + 1)) + 4);
        setGameState("game");
      };

      const spinWheel = () => {
        if (wheelSpinning) return;
        setWheelSpinning(true);
        setCurrentSector(null);

        const newTotalSpins = totalSpins + 1;
        const newSpinsInCurrentRound = spinsInCurrentRound + 1;
        setTotalSpins(newTotalSpins);
        setSpinsInCurrentRound(newSpinsInCurrentRound);

        let sector;
        let availableSectors = wheelSectors;

        if (currentRound === 1 && !hasBlackBoxTriggered && newSpinsInCurrentRound >= 5 && newSpinsInCurrentRound <= 7) {
          sector = wheelSectors.find(s => s.type === "blackbox");
        } else if (!hasBlitzTriggeredInCurrentRound && newSpinsInCurrentRound === blitzSpinIndex && newSpinsInCurrentRound >= 4 && newSpinsInCurrentRound <= 9) {
          const availableQuestions = gameData.blitzQuestionsPool.filter(q => !usedBlitzQuestions.includes(q));
          if (availableQuestions.length >= 5) {
            sector = wheelSectors.find(s => s.type === "blitz");
          }
        } else {
          availableSectors = wheelSectors.filter(sector => {
            if (sector.type === "blackbox") {
              return currentRound === 1 && !hasBlackBoxTriggered && newSpinsInCurrentRound >= 5 && newSpinsInCurrentRound <= 7;
            }
            if (sector.type === "blitz") {
              return !hasBlitzTriggeredInCurrentRound && newSpinsInCurrentRound === blitzSpinIndex && newSpinsInCurrentRound >= 4 && newSpinsInCurrentRound <= 9;
            }
            return true;
          });
          const randomSectorIndex = Math.floor(Math.random() * availableSectors.length);
          sector = availableSectors[randomSectorIndex];
        }

        const originalIndex = wheelSectors.findIndex(s => s === sector);
        const sectorAngle = (2 * Math.PI / wheelSectors.length) * originalIndex - Math.PI / 2 + Math.PI / wheelSectors.length;
        setFinalAngle(-sectorAngle);

        playAudio("wheel-spin-audio", 0.5);

        setTimeout(() => {
          setWheelSpinning(false);
          setCurrentSector(sector);
          stopAudio("wheel-spin-audio");
          switch(sector?.type) {
            case "blackbox":
              setHasBlackBoxTriggered(true);
              setBlackBoxVisible(true);
              playAudio("blackbox-sector-audio", 0.5);
              setTimeout(() => {
                setBlackBoxVisible(false);
                setShowBlackBoxChoice(true);
              }, 3000);
              break;
            case "blitz":
              if (hasBlitzTriggeredInCurrentRound) {
                setTimeout(() => {
                  nextPlayer();
                }, 1000);
                break;
              }
              const availableQuestions = gameData.blitzQuestionsPool.filter(q => !usedBlitzQuestions.includes(q));
              if (availableQuestions.length < 5) {
                setShowBlitz(false);
                setTimeout(() => {
                  nextPlayer();
                }, 1000);
                break;
              }
              const selectedQuestions = availableQuestions.slice(0, 5);
              setCurrentBlitzQuestions(selectedQuestions);
              setUsedBlitzQuestions(prev => [...prev, ...selectedQuestions]);
              setShowBlitz(true);
              setBlitzStarted(false);
              setBlitzAnswers([]);
              setTimeLeft(10);
              setHasBlitzTriggeredInCurrentRound(true);
              playAudio("blitz-start-audio", 0.5);
              break;
            case "plus":
              setShowPlusChoice(true);
              playAudio("plus-sector-audio", 0.5);
              break;
            default:
              break;
          }
        }, 6500); // 6.5 секунд
      };

      const handleBlackBoxChoice = (points) => {
        const selectedTeam = teams[currentPlayerIndex];
        const newScores = { ...scores };
        newScores[selectedTeam] += points;
        setScores(newScores);
        setShowBlackBoxChoice(false);
        setTimeout(() => {
          nextPlayer();
        }, 2000);
      };

      const handleBlackBoxDecline = () => {
        setShowBlackBoxChoice(false);
        setTimeout(() => {
          nextPlayer();
        }, 2000);
      };

      const handlePlusChoice = (position) => {
        const currentWord = gameData.rounds[currentRound]?.word;
        if (!currentWord) return;
        setAnimationIndex(position);
        setTimeout(() => {
          if (currentWord[position] && !revealedLetters.includes(position)) {
            setRevealedLetters([...revealedLetters, position]);
            setUsedLetters([...usedLetters, currentWord[position].toUpperCase()]);
            playAudio("correct-letter-audio", 0.5);
          }
          setAnimationIndex(null);
          setShowPlusChoice(false);
          setTimeout(() => {
            nextPlayer();
          }, 1000);
        }, 1000);
      };

      const startBlitz = () => {
        stopAudio("blitz-start-audio");
        setBlitzStarted(true);
        setTimeLeft(10);
        const timer = setInterval(() => {
          setTimeLeft(prev => {
            if (prev <= 1) {
              clearInterval(timer);
              return 0;
            }
            return prev - 1;
          });
        }, 1000);
        setBlitzTimer(timer);
      };

      const checkBlitzAnswer = (isCorrect) => {
        const correctAnswer = currentBlitzQuestions[blitzAnswers.length].match(/\(([^)]+)\)/)[1].toLowerCase();
        const newAnswers = [...blitzAnswers, isCorrect];
        setBlitzAnswers(newAnswers);
        if (isCorrect) {
          playAudio("correct-blitz-audio", 0.5);
          const newScores = { ...scores };
          newScores[teams[currentPlayerIndex]] += 100;
          setScores(newScores);
        } else {
          playAudio("wrong-blitz-audio", 0.5);
        }
        if (newAnswers.length < 5) {
          clearInterval(blitzTimer);
          setTimeLeft(10);
          const timer = setInterval(() => {
            setTimeLeft(prev => {
              if (prev <= 1) {
                clearInterval(timer);
                return 0;
              }
              return prev - 1;
            });
          }, 1000);
          setBlitzTimer(timer);
        } else {
          endBlitz();
        }
      };

      const endBlitz = () => {
        clearInterval(blitzTimer);
        setBlitzTimer(null);
        setBlitzStarted(false);
        setTimeout(() => {
          setShowBlitz(false);
          setCurrentBlitzQuestions([]);
          nextPlayer();
        }, 3300);
      };

      const checkLetter = (letter) => {
        if (!letter || letter.length !== 1 || !currentSector) return;
        const upperLetter = letter.toUpperCase();
        const currentWord = gameData.rounds[currentRound]?.word;
        if (!currentWord) return;
        const letterPositions = [];
        for (let i = 0; i < currentWord.length; i++) {
          if (currentWord[i] === upperLetter && !revealedLetters.includes(i)) {
            letterPositions.push(i);
          }
        }

        clearTimeout(letterShakeTimeout);
        if (letterPositions.length > 0) {
          let index = 0;
          const animateNextLetter = () => {
            if (index < letterPositions.length) {
              setAnimationIndex(letterPositions[index]);
              playAudio("correct-letter-audio", 0.5);
              index++;
              setTimeout(animateNextLetter, 500);
            } else {
              setRevealedLetters(prev => [...prev, ...letterPositions]);
              setUsedLetters([...usedLetters, upperLetter]);
              if (currentSector.type === "points") {
                const newScores = { ...scores };
                newScores[teams[currentPlayerIndex]] += currentSector.value;
                setScores(newScores);
              }
              if (revealedLetters.length + letterPositions.length === currentWord.length) {
                setTimeout(() => {
                  endRound(teams[currentPlayerIndex]);
                }, 2000);
              } else {
                setCurrentSector(null);
              }
              setAnimationIndex(null);
            }
          };
          animateNextLetter();
        } else {
          const unrevealedIndices = [];
          for (let i = 0; i < currentWord.length; i++) {
            if (!revealedLetters.includes(i)) {
              unrevealedIndices.push(i);
            }
          }
          const randomIndex = unrevealedIndices.length > 0 
            ? unrevealedIndices[Math.floor(Math.random() * unrevealedIndices.length)] 
            : null;
          if (randomIndex !== null) {
            setAnimationIndex(randomIndex);
            setTimeout(() => {
              playAudio("wrong-letter-audio", 0.5);
              setUsedLetters([...usedLetters, upperLetter]);
              nextPlayer();
              setCurrentSector(null);
              setAnimationIndex(null);
            }, 3500);
          }
        }
        setLetterShakeTimeout(setTimeout(() => setAnimationIndex(null), 3500));
      };

      const checkWord = (word) => {
        const currentWord = gameData.rounds[currentRound]?.word;
        if (!currentWord) return;
        clearTimeout(wordShakeTimeout);
        if (word.toUpperCase() === currentWord) {
          const lettersToReveal = [];
          for (let i = 0; i < currentWord.length; i++) {
            if (!revealedLetters.includes(i)) {
              lettersToReveal.push(i);
            }
          }
          setRevealedLetters(prev => [...prev, ...lettersToReveal]);
          
          let index = 0;
          const interval = setInterval(() => {
            if (index < currentWord.length) {
              setAnimationIndex(index);
              index++;
            } else {
              clearInterval(interval);
              setAnimationIndex(null);
              if (currentSector && currentSector.type === "points") {
                const newScores = { ...scores };
                newScores[teams[currentPlayerIndex]] += currentSector.value * 2;
                setScores(newScores);
              }
              playAudio("word-guess-audio", 0.5);
              setTimeout(() => {
                endRound(teams[currentPlayerIndex]);
              }, 2000);
            }
          }, 500);
        } else {
          for (let i = 0; i < currentWord.length; i++) {
            setAnimationIndex(i);
          }
          setTimeout(() => {
            setAnimationIndex(null);
            playAudio("wrong-word-audio", 0.5);
            const newScores = { ...scores };
            newScores[teams[currentPlayerIndex]] -= currentSector && currentSector.type === "points" ? currentSector.value : 0;
            setScores(newScores);
            nextPlayer();
            setCurrentSector(null);
          }, 3500);
        }
        setWordShakeTimeout(setTimeout(() => {
          for (let i = 0; i < currentWord.length; i++) {
            setAnimationIndex(null);
          }
        }, 3500));
        setShowWordSlider(false);
        setWordGuess("");
      };

      const nextPlayer = () => {
        setCurrentPlayerIndex((prevIndex) => (prevIndex + 1) % teams.length);
        setCurrentSector(null);
      };

      const endRound = (winner) => {
        const newWinners = winner ? [...winners, winner] : winners;
        setWinners(newWinners);
        if (currentRound < 4 && gameData.rounds[currentRound]) {
          setCurrentRound(prev => prev + 1);
          setRevealedLetters([]);
          setUsedLetters([]);
          setCurrentSector(null);
          setWheelSpinning(false);
          setCurrentPlayerIndex(Math.floor(Math.random() * teams.length));
          setGameState("roundIntro");
        } else {
          const sortedTeams = Object.entries(scores).sort((a, b) => b[1] - a[1]);
          const topThree = sortedTeams.slice(0, 3).map(([team, score]) => ({ team, score }));
          setPodiumTeams(topThree);
          setGameState("podium");
          setTimeout(() => setPodiumVisible(prev => ({ ...prev, 1: true })), 1000);
          setTimeout(() => setPodiumVisible(prev => ({ ...prev, 2: true })), 2000);
          setTimeout(() => setPodiumVisible(prev => ({ ...prev, 3: true })), 3000);
          playAudio("podium-fanfare-audio", 0.7);
        }
      };

      const startFinalRound = () => {
        setRevealedLetters([]);
        setUsedLetters([]);
        setCurrentPlayerIndex(Math.floor(Math.random() * teams.length));
        setGameState("final");
      };

      const checkFinalLetter = (letter) => {
        if (!letter || letter.length !== 1 || !currentSector) return;
        const upperLetter = letter.toUpperCase();
        const currentWord = gameData.finalRound.word;
        const letterPositions = [];
        for (let i = 0; i < currentWord.length; i++) {
          if (currentWord[i] === upperLetter && !revealedLetters.includes(i)) {
            letterPositions.push(i);
          }
        }

        clearTimeout(letterShakeTimeout);
        if (letterPositions.length > 0) {
          let index = 0;
          const animateNextLetter = () => {
            if (index < letterPositions.length) {
              setAnimationIndex(letterPositions[index]);
              playAudio("correct-letter-audio", 0.5);
              index++;
              setTimeout(animateNextLetter, 500);
            } else {
              setRevealedLetters([...revealedLetters, ...letterPositions]);
              setUsedLetters([...usedLetters, upperLetter]);
              if (currentSector.type === "points") {
                const newScores = { ...scores };
                newScores[teams[currentPlayerIndex]] += currentSector.value;
                setScores(newScores);
              }
              if (revealedLetters.length + letterPositions.length === currentWord.length) {
                setTimeout(() => {
                  endFinalRound(teams[currentPlayerIndex]);
                }, 2000);
              } else {
                setCurrentSector(null);
              }
              setAnimationIndex(null);
            }
          };
          animateNextLetter();
        } else {
          const unrevealedIndices = [];
          for (let i = 0; i < currentWord.length; i++) {
            if (!revealedLetters.includes(i)) {
              unrevealedIndices.push(i);
            }
          }
          const randomIndex = unrevealedIndices.length > 0 
            ? unrevealedIndices[Math.floor(Math.random() * unrevealedIndices.length)] 
            : null;
          if (randomIndex !== null) {
            setAnimationIndex(randomIndex);
            setTimeout(() => {
              playAudio("wrong-letter-audio", 0.5);
              setUsedLetters([...usedLetters, upperLetter]);
              nextPlayer();
              setCurrentSector(null);
              setAnimationIndex(null);
            }, 3500);
          }
        }
        setLetterShakeTimeout(setTimeout(() => setAnimationIndex(null), 3500));
      };

      const checkFinalWord = (word) => {
        if (word.toUpperCase() === gameData.finalRound.word) {
          const lettersToReveal = [];
          for (let i = 0; i < gameData.finalRound.word.length; i++) {
            if (!revealedLetters.includes(i)) lettersToReveal.push(i);
          }
          setRevealedLetters(prev => [...prev, ...lettersToReveal]);
          
          let index = 0;
          const interval = setInterval(() => {
            if (index < gameData.finalRound.word.length) {
              setAnimationIndex(index);
              index++;
            } else {
              clearInterval(interval);
              setAnimationIndex(null);
              if (currentSector && currentSector.type === "points") {
                const newScores = { ...scores };
                newScores[teams[currentPlayerIndex]] += currentSector.value * 2;
                setScores(newScores);
              }
              playAudio("word-guess-audio", 0.5);
              setTimeout(() => {
                endFinalRound(teams[currentPlayerIndex]);
              }, 2000);
            }
          }, 500);
        } else {
          for (let i = 0; i < gameData.finalRound.word.length; i++) {
            setAnimationIndex(i);
          }
          setTimeout(() => {
            setAnimationIndex(null);
            playAudio("wrong-word-audio", 0.5);
            const newScores = { ...scores };
            newScores[teams[currentPlayerIndex]] -= currentSector ? currentSector.value : 0;
            setScores(newScores);
            nextPlayer();
            setCurrentSector(null);
          }, 3500);
        }
        setShowWordSlider(false);
        setWordGuess("");
      };

      const endFinalRound = (winner) => {
        setGameState("gameOver");
      };

      const openWordSlider = () => {
        setShowWordSlider(true);
      };

      const closeWordSlider = () => {
        setShowWordSlider(false);
        setWordGuess("");
      };

      const restartGame = () => {
        setGameState("teamInput");
        setTeams([]);
        setScores({});
        setCurrentRound(0);
        setRevealedLetters([]);
        setUsedLetters([]);
        setCurrentPlayerIndex(0);
        setWinners([]);
        setBlackBoxVisible(false);
        setHasBlackBoxTriggered(false);
        setShowBlackBoxChoice(false);
        setShowWordSlider(false);
        setWordGuess("");
        setShowBlitz(false);
        setBlitzStarted(false);
        setBlitzAnswers([]);
        if (blitzTimer) clearInterval(blitzTimer);
        setBlitzTimer(null);
        setSpinsInCurrentRound(0);
        setTotalSpins(0);
        setPodiumTeams([]);
        setPodiumVisible({ 1: false, 2: false, 3: false });
        setShowPlusChoice(false);
        setAnimationIndex(null);
        setUsedBlitzQuestions([]);
        setCurrentBlitzQuestions([]);
        setHasBlitzTriggeredInCurrentRound(false);
        setBlitzSpinIndex(Math.floor(Math.random() * (9 - 4 + 1)) + 4);
        stopAllAudios();
      };

      const stopAllAudios = () => {
        activeAudios.forEach(audio => {
          audio.pause();
          audio.currentTime = 0;
        });
        setActiveAudios([]);
      };

      const stopAudio = (audioId) => {
        const audio = document.getElementById(audioId);
        if (audio) {
          audio.pause();
          audio.currentTime = 0;
          setActiveAudios(prev => prev.filter(a => a !== audio));
        }
      };

      const playAudio = (audioId, volumeLevel) => {
        stopAllAudios();
        const audio = document.getElementById(audioId);
        if (!audio) {
          console.error(`Аудио с ID ${audioId} не найдено`);
          return;
        }
        audio.volume = volumeLevel * (volume / 0.5);
        audio.currentTime = 0;
        audio.play().catch(error => {
          console.error(`Ошибка воспроизведения ${audioId}:`, error);
        });
        setActiveAudios(prev => [...prev, audio]);
      };

      const fadeAudio = (audioId, startTime, targetVolume) => {
        const audio = document.getElementById(audioId);
        if (!audio) {
          console.error(`Аудио с ID ${audioId} не найдено для затухания`);
          return;
        }
        let currentTime = startTime;
        const fadeInterval = setInterval(() => {
          if (currentTime <= 0) {
            audio.volume = targetVolume * (volume / 0.5);
            clearInterval(fadeInterval);
          } else {
            audio.volume = (currentTime / startTime) * (volume / 0.5);
            currentTime -= 0.1;
          }
        }, 100);
      };

      return (
        <div className="min-h-screen flex flex-col items-center justify-center p-4 relative">
          {gameState === "teamInput" && (
            <TeamInput onStart={startGame} />
          )}
          {gameState === "roundIntro" && (
            <RoundIntro 
              round={currentRound + 1}
              onStart={startRound}
            />
          )}
          {gameState === "game" && gameData.rounds[currentRound] && (
            <GameScreen
              teams={teams}
              currentPlayerIndex={currentPlayerIndex}
              scores={scores}
              word={gameData.rounds[currentRound].word}
              question={gameData.rounds[currentRound].question}
              revealedLetters={revealedLetters}
              usedLetters={usedLetters}
              wheelSpinning={wheelSpinning}
              currentSector={currentSector}
              onSpinWheel={spinWheel}
              onCheckLetter={checkLetter}
              onOpenWordSlider={openWordSlider}
              blackBoxVisible={blackBoxVisible}
              finalAngle={finalAngle}
              animationIndex={animationIndex}
              volume={volume}
              setVolume={setVolume}
            />
          )}
          {gameState === "finalIntro" && (
            <FinalIntro 
              theme={gameData.finalRound.theme}
              onStart={startFinalRound}
            />
          )}
          {gameState === "final" && (
            <FinalScreen
              teams={teams}
              currentPlayerIndex={currentPlayerIndex}
              word={gameData.finalRound.word}
              question={gameData.finalRound.question}
              revealedLetters={revealedLetters}
              usedLetters={usedLetters}
              wheelSpinning={wheelSpinning}
              currentSector={currentSector}
              onSpinWheel={spinWheel}
              onCheckLetter={checkFinalLetter}
              onOpenWordSlider={openWordSlider}
              finalAngle={finalAngle}
              animationIndex={animationIndex}
              volume={volume}
              setVolume={setVolume}
            />
          )}
          {gameState === "gameOver" && (
            <GameOver 
              winners={winners}
              scores={scores}
              onRestart={restartGame}
            />
          )}
          {gameState === "podium" && (
            <Podium 
              teams={podiumTeams}
              podiumVisible={podiumVisible}
              onFinish={() => setGameState("gameOver")}
            />
          )}
          <WordSlider
            isOpen={showWordSlider}
            wordGuess={wordGuess}
            onWordGuessChange={setWordGuess}
            onSubmit={gameState === "final" ? checkFinalWord : checkWord}
            onClose={closeWordSlider}
          />
          {showBlitz && currentBlitzQuestions.length > 0 && (
            <BlitzScreen
              question={currentBlitzQuestions[blitzAnswers.length]?.split('(')[0] || "Вопрос не доступен"}
              timeLeft={timeLeft}
              blitzAnswers={blitzAnswers}
              onCheckAnswer={checkBlitzAnswer}
              blitzStarted={blitzStarted}
              onStartBlitz={startBlitz}
            />
          )}
          {showBlackBoxChoice && (
            <BlackBoxChoice
              team={teams[currentPlayerIndex]}
              onAddPoints={handleBlackBoxChoice}
              onDecline={handleBlackBoxDecline}
            />
          )}
          {showPlusChoice && gameData.rounds[currentRound]?.word && (
            <PlusChoice
              wordLength={gameData.rounds[currentRound].word.length}
              onSelectPosition={handlePlusChoice}
              onClose={() => setShowPlusChoice(false)}
            />
          )}
        </div>
      );
    }

    function TeamInput({ onStart }) {
      const [teamNames, setTeamNames] = React.useState(["", "", "", "", ""]);
      const handleNameChange = (index, value) => {
        const newNames = [...teamNames];
        newNames[index] = value.slice(0, 20);
        setTeamNames(newNames);
      };
      const handleStart = () => {
        const validNames = teamNames.filter(name => name.trim() !== "");
        if (validNames.length > 0) {
          onStart(validNames);
        }
      };
      const canStart = teamNames.some(name => name.trim() !== "");
      return (
        <div className="bg-gray-800 p-6 rounded-lg shadow-lg max-w-md w-full">
          <h1 className="text-2xl font-bold mb-6 text-center">Поле Чудес</h1>
          <p className="mb-4">Введите названия 5 команд:</p>
          {teamNames.map((name, index) => (
            <div key={index} className="mb-3">
              <input
                type="text"
                value={name}
                onChange={(e) => handleNameChange(index, e.target.value)}
                placeholder={`Команда ${index + 1}`}
                className="w-full p-2 rounded bg-gray-700 border border-gray-600 focus:border-yellow-400 focus:outline-none"
              />
            </div>
          ))}
          <button
            onClick={handleStart}
            disabled={!canStart}
            className={`w-full mt-4 p-3 rounded font-bold ${canStart ? 'bg-yellow-500 hover:bg-yellow-600' : 'bg-gray-500 cursor-not-allowed'}`}
          >
            Начать игру
          </button>
        </div>
      );
    }

    function RoundIntro({ round, onStart }) {
      return (
        <div className="bg-gray-800 p-6 rounded-lg shadow-lg max-w-md w-full text-center">
          <h1 className="text-2xl font-bold mb-4">Раунд {round}</h1>
          <button
            onClick={onStart}
            className="w-full mt-4 p-3 rounded font-bold bg-yellow-500 hover:bg-yellow-600"
          >
            Начать раунд
          </button>
        </div>
      );
    }

    function GameScreen({
      teams,
      currentPlayerIndex,
      scores,
      word,
      question,
      revealedLetters,
      usedLetters,
      wheelSpinning,
      currentSector,
      onSpinWheel,
      onCheckLetter,
      onOpenWordSlider,
      blackBoxVisible,
      finalAngle,
      animationIndex,
      volume,
      setVolume
    }) {
      const [letterInput, setLetterInput] = React.useState("");
      const handleLetterSubmit = (e) => {
        e.preventDefault();
        if (letterInput && currentSector && !usedLetters.includes(letterInput.toUpperCase())) {
          onCheckLetter(letterInput);
          setLetterInput("");
        }
      };
      const isLetterUsed = letterInput && usedLetters.includes(letterInput.toUpperCase());

      return (
        <div className="w-full max-w-4xl">
          <div className="bg-gray-800 rounded-lg p-4 mb-6">
            <h2 className="text-xl font-bold mb-2 text-center">Счёт</h2>
            <div className="grid grid-cols-2 md:grid-cols-5 gap-2">
              {teams.map((team, index) => (
                <div 
                  key={team} 
                  className={`p-2 rounded ${index === currentPlayerIndex ? 'player-active bg-gray-700' : 'bg-gray-700'}`}
                >
                  <div className="font-semibold truncate">{team}</div>
                  <div className="text-lg">{scores[team] || 0}</div>
                </div>
              ))}
            </div>
          </div>
          <div className="bg-gray-800 p-4 rounded-lg mb-6 text-center">
            <h3 className="text-xl font-bold text-yellow-400">Вопрос:</h3>
            <p>{question}</p>
          </div>
          <div className="flex flex-wrap justify-center mb-8">
            {Array.from(word).map((_, index) => (
              <div 
                key={index} 
                className={`letter-box ${revealedLetters.includes(index) ? 'revealed' : ''} ${animationIndex === index ? 'shake' : ''}`}
                style={{ '--index': index }}
              >
                {revealedLetters.includes(index) ? word[index] : ''}
              </div>
            ))}
          </div>
          <div className="text-center my-4">
            <h2 className="text-xl font-bold">Сейчас ходит: <span className="text-yellow-400">{teams[currentPlayerIndex]}</span></h2>
          </div>
          <div className="flex flex-col items-center mt-6">
            <div className="relative mb-4">
              <Wheel spinning={wheelSpinning} sector={currentSector} finalAngle={finalAngle} />
              <div className="wheel-pointer"></div>
            </div>
            {!wheelSpinning && !currentSector && (
              <button
                onClick={onSpinWheel}
                className="px-6 py-3 bg-blue-600 hover:bg-blue-700 rounded-lg font-bold text-lg"
              >
                Крутить барабан
              </button>
            )}
            {currentSector && currentSector.type === "points" && (
              <div className="mt-4">
                <form onSubmit={handleLetterSubmit} className="flex flex-col items-center">
                  <input
                    type="text"
                    value={letterInput}
                    onChange={(e) => {
                      const val = e.target.value;
                      if (/^[а-яА-Я]?$/.test(val)) {
                        setLetterInput(val);
                      }
                    }}
                    maxLength={1}
                    placeholder="Введите букву"
                    className="w-16 h-16 text-3xl text-center rounded bg-gray-700 border border-gray-600 focus:border-yellow-400 focus:outline-none mb-4"
                    disabled={!currentSector || currentSector.type !== "points"}
                  />
                  <button
                    type="submit"
                    disabled={!letterInput || isLetterUsed || !currentSector || currentSector.type !== "points"}
                    className={`px-6 py-2 rounded font-bold ${!letterInput || isLetterUsed ? 'bg-gray-500 cursor-not-allowed' : 'bg-green-600 hover:bg-green-700'}`}
                  >
                    Назвать букву
                  </button>
                </form>
                <button
                  onClick={onOpenWordSlider}
                  className="mt-4 px-6 py-2 bg-yellow-500 hover:bg-yellow-600 rounded font-bold slide-up-button"
                >
                  Назвать слово
                </button>
              </div>
            )}
          </div>
          <div className="mt-6 text-center">
            <p>Использованные буквы: {usedLetters.join(", ")}</p>
            <div className="volume-slider">
              <label>Громкость: </label>
              <input
                type="range"
                min="0"
                max="1"
                step="0.1"
                value={volume}
                onChange={(e) => setVolume(parseFloat(e.target.value))}
              />
            </div>
          </div>
          {blackBoxVisible && <BlackBoxAnimation />}
        </div>
      );
    }

    function Wheel({ spinning, sector, finalAngle }) {
      const canvasRef = React.useRef(null);
      React.useEffect(() => {
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        let angle = 0;
        let spinSpeed = 0;
        const sectorAngles = Array(wheelSectors.length).fill(0).map((_, i) => (2 * Math.PI / wheelSectors.length) * i - Math.PI/2);

        const draw = () => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.save();
          ctx.translate(200, 200);
          if (spinning) {
            spinSpeed = lerp(spinSpeed, 0.1, 0.02);
            angle += spinSpeed;
          } else if (finalAngle !== 0) {
            angle = lerp(angle, finalAngle, 0.1);
          }
          ctx.rotate(angle - Math.PI / 2);
          for (let i = 0; i < wheelSectors.length; i++) {
            const startAngle = sectorAngles[i];
            const endAngle = sectorAngles[(i + 1) % wheelSectors.length];
            if (wheelSectors[i].type === "blackbox") {
              ctx.fillStyle = '#000000';
            } else if (wheelSectors[i].type === "blitz") {
              ctx.fillStyle = '#FFD700';
            } else if (wheelSectors[i].type === "plus") {
              ctx.fillStyle = '#00FF00';
            } else {
              ctx.fillStyle = '#6495ED';
            }
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.arc(0, 0, 190, startAngle, endAngle);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.save();
            ctx.rotate((startAngle + endAngle) / 2);
            ctx.font = '16px Arial';
            ctx.fillStyle = '#000000';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            if (wheelSectors[i].type === "blackbox") {
              ctx.fillText("Ящик", 120, 0);
            } else if (wheelSectors[i].type === "blitz") {
              ctx.fillText("Блиц", 120, 0);
            } else if (wheelSectors[i].type === "plus") {
              ctx.fillText("+", 120, 0);
            } else {
              ctx.fillText(wheelSectors[i].value, 120, 0);
            }
            ctx.restore();
          }
          ctx.fillStyle = '#FFFFFF';
          ctx.beginPath();
          ctx.arc(0, 0, 20, 0, 2 * Math.PI);
          ctx.fill();
          ctx.restore();

          requestAnimationFrame(draw);
        };

        const lerp = (start, end, t) => start + t * (end - start);
        draw();
      }, [spinning, finalAngle]);

      return (
        <div className="relative">
          <canvas ref={canvasRef} width="400" height="400"></canvas>
          {sector && (
            <div className="mt-4 text-center">
              <p className="text-xl font-bold">
                {sector.type === "blackbox" ? "Чёрный ящик!" : 
                 sector.type === "blitz" ? "Блиц-раунд!" : 
                 sector.type === "plus" ? "Сектор '+'!" : 
                 `Выпало: ${sector.value} очков`}
              </p>
            </div>
          )}
        </div>
      );
    }

    function BlackBoxAnimation() {
      const canvasRef = React.useRef(null);
      React.useEffect(() => {
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        let scale = 0;
        let opacity = 0;

        const draw = () => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.save();
          ctx.translate(canvas.width / 2, canvas.height / 2);
          scale = lerp(scale, 1, 0.1);
          opacity = lerp(opacity, 255, 0.1);
          ctx.scale(scale, scale);
          ctx.fillStyle = `rgba(0, 0, 0, ${opacity / 255})`;
          ctx.strokeStyle = `rgba(255, 255, 255, ${opacity / 255})`;
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.roundRect(-150, -100, 300, 200, 20);
          ctx.fill();
          ctx.stroke();
          ctx.fillStyle = `rgba(255, 255, 255, ${opacity / 255})`;
          ctx.font = '32px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText("Чёрный ящик", 0, 0);
          ctx.restore();

          requestAnimationFrame(draw);
        };

        const lerp = (start, end, t) => start + t * (end - start);
        draw();
      }, []);

      return (
        <canvas
          ref={canvasRef}
          width="400"
          height="300"
          style={{ position: 'fixed', top: '50%', left: '50%', transform: 'translate(-50%, -50%)', zIndex: 100 }}
        ></canvas>
      );
    }

    function BlackBoxChoice({ team, onAddPoints, onDecline }) {
      const [points, setPoints] = React.useState("");

      const handleSubmit = (e) => {
        e.preventDefault();
        const pointsValue = parseInt(points, 10);
        if (pointsValue > 0) {
          onAddPoints(pointsValue);
        }
      };

      return (
        <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50">
          <div className="bg-gray-800 p-6 rounded-lg shadow-lg text-center max-w-md w-full">
            <h3 className="text-xl font-bold mb-4">Чёрный ящик</h3>
            <p className="mb-4">Введите количество очков для команды <span className="text-yellow-400">{team}</span>:</p>
            <form onSubmit={handleSubmit} className="flex flex-col items-center">
              <input
                type="number"
                value={points}
                onChange={(e) => setPoints(e.target.value)}
                placeholder="Введите очки"
                className="w-full p-2 rounded bg-gray-700 border border-gray-600 focus:border-yellow-400 focus:outline-none mb-4"
                min="1"
              />
              <div className="flex gap-4">
                <button
                  type="submit"
                  disabled={!points || parseInt(points) <= 0}
                  className={`px-6 py-2 rounded font-bold ${!points || parseInt(points) <= 0 ? 'bg-gray-500 cursor-not-allowed' : 'bg-green-600 hover:bg-green-700'}`}
                >
                  Добавить
                </button>
                <button
                  onClick={onDecline}
                  className="px-6 py-2 rounded font-bold bg-red-600 hover:bg-red-700"
                >
                  Отказаться
                </button>
              </div>
            </form>
          </div>
        </div>
      );
    }

    function PlusChoice({ wordLength, onSelectPosition, onClose }) {
      const [position, setPosition] = React.useState("");

      const handleSubmit = (e) => {
        e.preventDefault();
        const pos = parseInt(position, 10) - 1;
        if (pos >= 0 && pos < wordLength) {
          onSelectPosition(pos);
        }
      };

      return (
        <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50">
          <div className="bg-gray-800 p-6 rounded-lg shadow-lg text-center max-w-md w-full">
            <h3 className="text-xl font-bold mb-4">Сектор '+'</h3>
            <p className="mb-4">Выберите позицию буквы (от 1 до {wordLength}):</p>
            <form onSubmit={handleSubmit} className="flex flex-col items-center">
              <input
                type="number"
                value={position}
                onChange={(e) => setPosition(e.target.value)}
                placeholder={`1 - ${wordLength}`}
                className="w-full p-2 rounded bg-gray-700 border border-gray-600 focus:border-yellow-400 focus:outline-none mb-4"
                min="1"
                max={wordLength}
              />
              <button
                type="submit"
                disabled={!position || parseInt(position) < 1 || parseInt(position) > wordLength}
                className={`px-6 py-2 rounded font-bold ${!position || parseInt(position) < 1 || parseInt(position) > wordLength ? 'bg-gray-500 cursor-not-allowed' : 'bg-green-600 hover:bg-green-700'}`}
              >
                Выбрать
              </button>
              <button
                onClick={onClose}
                className="mt-2 px-6 py-2 rounded font-bold bg-red-600 hover:bg-red-700"
              >
                Отмена
              </button>
            </form>
          </div>
        </div>
      );
    }

    function FinalIntro({ theme, onStart }) {
      return (
        <div className="bg-gray-800 p-6 rounded-lg shadow-lg max-w-md w-full text-center">
          <h1 className="text-2xl font-bold mb-4">Финальный раунд</h1>
          <h2 className="text-xl mb-6">Тема: <span className="text-yellow-400">{theme}</span></h2>
          <button
            onClick={onStart}
            className="w-full mt-4 p-3 rounded font-bold bg-yellow-500 hover:bg-yellow-600"
          >
            Начать финал
          </button>
        </div>
      );
    }

    function FinalScreen({
      teams,
      currentPlayerIndex,
      word,
      question,
      revealedLetters,
      usedLetters,
      wheelSpinning,
      currentSector,
      onSpinWheel,
      onCheckLetter,
      onOpenWordSlider,
      finalAngle,
      animationIndex,
      volume,
      setVolume
    }) {
      const [letterInput, setLetterInput] = React.useState("");
      const handleLetterSubmit = (e) => {
        e.preventDefault();
        if (letterInput && currentSector && !usedLetters.includes(letterInput.toUpperCase())) {
          onCheckLetter(letterInput);
          setLetterInput("");
        }
      };
      const isLetterUsed = letterInput && usedLetters.includes(letterInput.toUpperCase());

      return (
        <div className="w-full max-w-4xl">
          <div className="text-center my-4">
            <h2 className="text-xl font-bold">Сейчас ходит: <span className="text-yellow-400">{teams[currentPlayerIndex]}</span></h2>
          </div>
          <div className="bg-gray-800 p-4 rounded-lg mb-6 text-center">
            <h3 className="text-xl font-bold text-yellow-400">Вопрос:</h3>
            <p>{question}</p>
          </div>
          <div className="flex flex-wrap justify-center mb-8">
            {Array.from(word).map((_, index) => (
              <div 
                key={index} 
                className={`letter-box ${revealedLetters.includes(index) ? 'revealed' : ''} ${animationIndex === index ? 'shake' : ''}`}
                style={{ '--index': index }}
              >
                {revealedLetters.includes(index) ? word[index] : ''}
              </div>
            ))}
          </div>
          <div className="flex flex-col items-center mt-6">
            <div className="relative mb-4">
              <Wheel spinning={wheelSpinning} sector={currentSector} finalAngle={finalAngle} />
              <div className="wheel-pointer"></div>
            </div>
            {!wheelSpinning && !currentSector && (
              <button
                onClick={onSpinWheel}
                className="px-6 py-3 bg-blue-600 hover:bg-blue-700 rounded-lg font-bold text-lg"
              >
                Крутить барабан
              </button>
            )}
            {currentSector && currentSector.type === "points" && (
              <div className="mt-4">
                <form onSubmit={handleLetterSubmit} className="flex flex-col items-center">
                  <input
                    type="text"
                    value={letterInput}
                    onChange={(e) => {
                      const val = e.target.value;
                      if (/^[а-яА-Я]?$/.test(val)) {
                        setLetterInput(val);
                      }
                    }}
                    maxLength={1}
                    placeholder="Введите букву"
                    className="w-16 h-16 text-3xl text-center rounded bg-gray-700 border border-gray-600 focus:border-yellow-400 focus:outline-none mb-4"
                    disabled={!currentSector || currentSector.type !== "points"}
                  />
                  <button
                    type="submit"
                    disabled={!letterInput || isLetterUsed || !currentSector || currentSector.type !== "points"}
                    className={`px-6 py-2 rounded font-bold ${!letterInput || isLetterUsed ? 'bg-gray-500 cursor-not-allowed' : 'bg-green-600 hover:bg-green-700'}`}
                  >
                    Назвать букву
                  </button>
                </form>
                <button
                  onClick={onOpenWordSlider}
                  className="mt-4 px-6 py-2 bg-yellow-500 hover:bg-yellow-600 rounded font-bold slide-up-button"
                >
                  Назвать слово
                </button>
              </div>
            )}
          </div>
          <div className="mt-6 text-center">
            <p>Использованные буквы: {usedLetters.join(", ")}</p>
            <div className="volume-slider">
              <label>Громкость: </label>
              <input
                type="range"
                min="0"
                max="1"
                step="0.1"
                value={volume}
                onChange={(e) => setVolume(parseFloat(e.target.value))}
              />
            </div>
          </div>
        </div>
      );
    }

    function WordSlider({ isOpen, wordGuess, onWordGuessChange, onSubmit, onClose }) {
      const handleSubmit = (e) => {
        e.preventDefault();
        if (wordGuess) {
          onSubmit(wordGuess);
        }
      };
      return (
        <div className={`word-slider ${isOpen ? 'open' : ''}`}>
          <div className="flex justify-between items-center mb-4">
            <h3 className="text-xl font-bold">Назовите слово</h3>
            <button onClick={onClose} className="text-gray-400 hover:text-white">
              ✕
            </button>
          </div>
          <form onSubmit={handleSubmit}>
            <input
              type="text"
              value={wordGuess}
              onChange={(e) => onWordGuessChange(e.target.value)}
              placeholder="Введите слово целиком"
              className="w-full p-4 rounded-lg bg-gray-700 border border-gray-600 focus:border-yellow-400 focus:outline-none mb-4"
            />
            <button
              type="submit"
              disabled={!wordGuess}
              className={`w-full p-4 rounded-lg font-bold ${!wordGuess ? 'bg-gray-500 cursor-not-allowed' : 'bg-yellow-500 hover:bg-yellow-600'}`}
            >
              Проверить
            </button>
          </form>
        </div>
      );
    }

    function BlitzScreen({ question, timeLeft, blitzAnswers, onCheckAnswer, blitzStarted, onStartBlitz }) {
      return (
        <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50">
          <div className="bg-gray-800 p-6 rounded-lg shadow-lg text-center max-w-md w-full">
            <h3 className="text-xl font-bold mb-4">Блиц-раунд!</h3>
            {!blitzStarted ? (
              <>
                <p className="mb-4">Подготовьтесь к пяти быстрым вопросам!</p>
                <button
                  onClick={onStartBlitz}
                  className="px-6 py-2 rounded font-bold bg-yellow-500 hover:bg-yellow-600"
                >
                  Начать
                </button>
              </>
            ) : (
              <>
                {timeLeft > 0 && <p className="mb-2">Время: {timeLeft} сек</p>}
                <p className="mb-4">{question}</p>
                <div className="mb-4">
                  {blitzAnswers.map((isCorrect, index) => (
                    <span key={index}>
                      {isCorrect ? (
                        <span className="blitz-answer blitz-correct">✓</span>
                      ) : (
                        <span className="blitz-answer blitz-wrong">✗</span>
                      )}
                    </span>
                  ))}
                </div>
                <div className="flex justify-center gap-6">
                  <button
                    onClick={() => onCheckAnswer(true)}
                    className="px-6 py-2 bg-green-600 hover:bg-green-700 rounded font-bold"
                  >
                    ✓
                  </button>
                  <button
                    onClick={() => onCheckAnswer(false)}
                    className="px-6 py-2 bg-red-600 hover:bg-red-700 rounded font-bold"
                  >
                    ✗
                  </button>
                </div>
              </>
            )}
          </div>
        </div>
      );
    }

    function GameOver({ winners, scores, onRestart }) {
      return (
        <div className="bg-gray-800 p-6 rounded-lg shadow-lg max-w-md w-full text-center">
          <h1 className="text-2xl font-bold mb-6">Игра завершена!</h1>
          {winners.length > 0 ? (
            <>
              <h2 className="text-xl mb-4">Победитель: <span className="text-yellow-400">{winners[winners.length - 1]}</span></h2>
              <div className="mb-6">
                <h3 className="font-bold mb-2">Итоговый счёт:</h3>
                {Object.entries(scores).map(([team, score]) => (
                  <div key={team} className="flex justify-between">
                    <span>{team}:</span>
                    <span>{score}</span>
                  </div>
                ))}
              </div>
            </>
          ) : (
            <p className="mb-6">Победителя нет</p>
          )}
          <button
            onClick={onRestart}
            className="w-full mt-4 p-3 rounded font-bold bg-yellow-500 hover:bg-yellow-600"
          >
            Новая игра
          </button>
        </div>
      );
    }

    function FloatingCircles({ count = 30 }) {
  const circles = React.useMemo(() => {
    const colors = ['#FF6347', '#FFD700', '#00FF7F', '#1E90FF', '#FF69B4'];
    return Array.from({ length: count }, (_, index) => {
      const size = Math.random() * 10 + 5;
      const startX = Math.random() * window.innerWidth;
      const startY = Math.random() * window.innerHeight;
      const moveX = (Math.random() - 0.4) * 200;
      const moveY = (Math.random() - 0.4) * 200;
      const color = colors[Math.floor(Math.random() * colors.length)];
      const duration = Math.random() * 3 + 2; // Исправлено здесь
      const delay = Math.random() * 2;

      return {
        id: index,
        style: {
          width: `${size}px`,
          height: `${size}px`,
          backgroundColor: color,
          left: `${startX}px`,
          top: `${startY}px`,
          animation: `floatCircle ${duration}s ease-in-out ${delay}s infinite`,
          '--move-x': `${moveX}px`,
          '--move-y': `${moveY}px`,
        }
      };
    });
  }, [count]);

  return (
    <div className="absolute inset-0 pointer-events-none z-10">
      {circles.map(circle => (
        <div
          key={circle.id}
          className="floating-circle"
          style={circle.style}
        />
      ))}
    </div>
  );
}

    function Podium({ teams, podiumVisible, onFinish }) {
      React.useEffect(() => {
        const timer = setTimeout(() => {
          const hideTimer = setTimeout(() => {
            onFinish();
          }, 8000);
          return () => clearTimeout(hideTimer);
        }, 1000);
        return () => clearTimeout(timer);
      }, [onFinish]);

      return (
        <div className="relative w-full h-screen flex items-center justify-center">
          <FloatingCircles count={50} />
          <div className="podium">
            {teams.map((teamData, index) => {
              const position = index + 1; // 1-е место: index 0, 2-е место: index 1, 3-е место: index 2
              return (
                <div
                  key={teamData.team}
                  className={`podium-step ${podiumVisible[position] ? 'visible' : ''}`}
                >
                  <div className="podium-team text-black">
                    {position} место<br />
                    {teamData.team}<br />
                    {teamData.score} очков
                  </div>
                </div>
              );
            })}
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
